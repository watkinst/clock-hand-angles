{"version":3,"sources":["cha.ts"],"names":["clock","draw","ctx","drawFace","radius","drawDegreeNumbers","drawDegreeMarkers","drawTimeNumbers","drawTime","drawAngles","findSameAngle","timesToRender","hourHandDegreesMoved","minuteHandDegreesMoved","difference","currentHour","minutes","seconds","canvases","document","querySelectorAll","newCanvas","context","i","j","Math","abs","innerAngleDegrees","outerAngleDegrees","Number","hour","value","push","splice","length","parentNode","removeChild","createElement","setAttribute","secondCanvas","appendChild","getContext","translate","panel2","style","display","drawAdditionalClock","time","drawAdditionalTime","h","m","s","convertToRadians","drawHand","grad","beginPath","arc","PI","fillStyle","fill","createRadialGradient","addColorStop","strokeStyle","lineWidth","stroke","reverse","ang","font","textBaseline","textAlign","rotate","num","fillText","toString","moveTo","lineTo","minute","second","unit","radians","pos","width","lineCap","additional","startPosition","endPosition","c2_posAngle","innerHTML","toFixed","c2_negAngle","c1_posAngle","c1_negAngle","canvas","querySelector","numberInputs","addEventListener","evt","preventDefault","height"],"mappings":"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","file":"cha.js","sourcesContent":["const clock = (function() {\n\n  interface timeToRender {\n    hour: number,\n    minutes: number,\n    seconds: number\n  }\n\n  // clock on the left that is controlled by the time inputs\n  const canvas: HTMLCanvasElement = <HTMLCanvasElement>document.querySelector('#canvas');\n\n  // the panel that holds the second clock\n  const panel2: HTMLElement = <HTMLElement>document.querySelector('.clock-panel-2');\n\n  // where we append the clock that appears on the right\n  const secondCanvas: HTMLCanvasElement = <HTMLCanvasElement>document.querySelector('.second-canvas');\n\n  // areas to display exact angles from both clocks\n  const c1_negAngle: HTMLElement = <HTMLElement>document.querySelector('.c1-neg-angle');\n  const c1_posAngle: HTMLElement = <HTMLElement>document.querySelector('.c1-pos-angle');\n  const c2_negAngle: HTMLElement = <HTMLElement>document.querySelector('.c2-neg-angle');\n  const c2_posAngle: HTMLElement = <HTMLElement>document.querySelector('.c2-pos-angle');\n\n  // the hour, minute, and second number inputs\n  const hour: HTMLInputElement = <HTMLInputElement>document.querySelector('#hour');\n  const minute: HTMLInputElement = <HTMLInputElement>document.querySelector('#minute');\n  const second: HTMLInputElement = <HTMLInputElement>document.querySelector('#second');\n\n  // disable typing in the number inputs\n  const numberInputs: NodeListOf<Element> = document.querySelectorAll('[type=\"number\"]');\n  for (let i: number = 0; i < numberInputs.length; i++) {\n    numberInputs[i].addEventListener(\"keypress\", function(evt) {\n      evt.preventDefault();\n    });\n  }\n\n  const ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n  let radius: number = canvas.height / 2;\n\n  let outerAngleDegrees: number = 0;\n  let innerAngleDegrees: number = 0;\n\n  // moves the circle origin to the center of the\n  // canvas, so we get to see the whole clock\n  ctx.translate(radius, radius);\n\n  // slightly shrink the radius to allow for some\n  // padding between the clock and the canvas edge\n  radius = radius * 0.90;\n\n  // render the initial clock\n  draw(ctx);\n\n  function draw(ctx: CanvasRenderingContext2D): void {\n    drawFace(ctx, radius);\n    drawDegreeNumbers(ctx, radius, false);\n    drawDegreeNumbers(ctx, radius, true);\n    drawDegreeMarkers(ctx, radius);\n    drawTimeNumbers(ctx, radius);\n    drawTime(ctx, radius);\n    drawAngles(ctx, radius, null, false);\n\n    // does the angle between the clock hands\n    // occur anywhere else on the clock face?\n    findSameAngle();\n  }\n\n  function findSameAngle(): void {\n    // distance moved per second\n    const hourHandDps: number = 0.008333333333333;\n    const minuteHandDps: number = 0.1;\n\n    // holds any times with a matching\n    // angle between the clock hands\n    const timesToRender: timeToRender[] = [];\n\n    // degrees moved and difference\n    let hourHandDegreesMoved: number = 0;\n    let minuteHandDegreesMoved: number = 0;\n    let difference: number = 0;\n\n    // our tolerance for error\n    const acceptedDiff: number = 0.001;\n\n    // the hour we are currently checking\n    let currentHour: number = 0;\n\n    // minutes and seconds where a matching angle occurs\n    let minutes: number = 0;\n    let seconds: number = 0;\n\n    // all canvases on our page\n    let canvases: NodeListOf<Element> = document.querySelectorAll('.canvas');\n\n    // used to create a new canvas and context that\n    // gets used if a matching angle is found\n    let newCanvas: HTMLCanvasElement = null;\n    let context: CanvasRenderingContext2D = null;\n\n    // check through all hours, beginning at\n    // noon (0), looking for a matching angle\n    for (let i: number = 0; i <= 330; i += 30) {\n      // check all 3600 seconds in each hour\n      for (let j: number = 0; j <= 3600; j++) {\n        hourHandDegreesMoved = i + (j * hourHandDps);\n        minuteHandDegreesMoved = j * minuteHandDps;\n        difference = minuteHandDegreesMoved - hourHandDegreesMoved;\n\n        currentHour = 0;\n\n        switch (i) {\n          case 0:\n            currentHour = 12;\n            break;\n          default:\n            currentHour = i / 30;\n        }\n\n        // if the angle ( difference ) between the clock hands at the time\n        // being tested is within 1/1000th of a degree of the positive or\n        // negative angle formed by the first clock's hour and minute hands\n        // then we have a match\n        if((Math.abs(difference - innerAngleDegrees) < acceptedDiff) ||\n           (Math.abs(difference + innerAngleDegrees) < acceptedDiff) ||\n           (Math.abs(difference - outerAngleDegrees) < acceptedDiff) ||\n           (Math.abs(difference + outerAngleDegrees) < acceptedDiff)) {\n          // get minutes and seconds from our inner counter\n          minutes = (j - (j % 60)) / 60;\n          seconds = j % 60;\n\n          // bump the hours up if we have 60 minutes\n          if (minutes === 60) {\n            minutes = 0;\n            currentHour = currentHour + 1;\n          }\n\n          // avoid any hours like 0 or 13, 14, etc ...\n          currentHour = currentHour % 12;\n\n          if (currentHour == 0) {\n            currentHour = 12;\n          }\n\n          // the same angle can't occur within the same hour\n          if (currentHour != Number(hour.value)) {\n            timesToRender.push({\n              hour: currentHour,\n              minutes: minutes,\n              seconds: seconds\n            });\n          }\n        }\n      }\n    }\n\n    // since each angle actually occurs twice, but we only\n    // need the one that is not during the current hour\n    timesToRender.splice(1, 1);\n\n    // delete the prior canvas before\n    // creating and appending a new one\n    // Must do it this way because the one we want\n    // to remove is not there on initial page load\n    for (let i: number = 0; i < canvases.length; i++) {\n      if (i !== 0) {\n        canvases[i].parentNode.removeChild(canvases[i]);\n      }\n    }\n\n    // create and append a new canvas\n    newCanvas = <HTMLCanvasElement>document.createElement('canvas');\n    newCanvas.setAttribute('id', 'canvas1');\n    newCanvas.setAttribute('class', 'canvas');\n    newCanvas.setAttribute('width', '800');\n    newCanvas.setAttribute('height', '800');\n\n    secondCanvas.appendChild(newCanvas);\n\n    context = newCanvas.getContext(\"2d\");\n\n    // must reset radius before translating\n    radius = radius * 1.1111111111111111;\n    context.translate(radius, radius);\n    radius = radius * 0.90\n\n    // if we got any matching times/angles\n    // then draw another clock\n    if (timesToRender.length) {\n      panel2.style.display = 'block';\n      drawAdditionalClock(context, timesToRender[0]);\n    } else {\n      panel2.style.display = 'none';\n    }\n  }\n\n  // draws the clock on the right\n  function drawAdditionalClock(ctx: CanvasRenderingContext2D, time: timeToRender): void {\n    drawFace(ctx, radius);\n    drawDegreeNumbers(ctx, radius, false);\n    drawDegreeNumbers(ctx, radius, true);\n    drawDegreeMarkers(ctx, radius);\n    drawTimeNumbers(ctx, radius);\n    drawAdditionalTime(ctx, radius, time);\n    drawAngles(ctx, radius, time, true);\n  }\n\n  // draws the time on the clock on the right\n  function drawAdditionalTime(ctx: CanvasRenderingContext2D, radius: number, time: timeToRender): void {\n    let h: number = Number(time.hour);\n    let m: number = Number(time.minutes);\n    let s: number = Number(time.seconds);\n\n    //hour\n    h = h % 12;\n    h = convertToRadians('hours', h, m, s);\n    drawHand(ctx, h, radius*0.71, radius*0.03);\n\n    //minute\n    m = convertToRadians('minutes', h, m, s);\n    drawHand(ctx, m, radius*0.8, radius*0.03);\n\n    // second\n    s = convertToRadians('seconds', h, m, s);\n    drawHand(ctx, s, radius*0.9, radius*0.01);\n  }\n\n  function drawFace(ctx: CanvasRenderingContext2D, radius: number): void {\n    let grad: CanvasGradient = null;\n    ctx.beginPath();\n\n    // Parameter          Description\n    // x                  The x-coordinate of the center of the circle\n    // y                  The y-coordinate of the center of the circle\n    // r                  The radius of the circle\n    // sAngle             The starting angle, in radians (0 is at the 3 o'clock\n    //                    position of the arc's circle, just like on a unit circle)\n    // eAngle             The ending angle, in radians\n    // counterclockwise   Optional. Specifies whether the drawing should be\n    //                    counterclockwise or clockwise. False is default, and\n    //                    indicates clockwise, while true indicates counter-clockwise.\n    ctx.arc(0, 0, radius, 0, 2*Math.PI);\n\n    // clock face color\n    ctx.fillStyle = 'white';\n\n    // fills the clock face\n    // with the above color\n    ctx.fill();\n\n    // draws the outside ring of the clock\n    grad = ctx.createRadialGradient(0,0,radius*0.95, 0,0,radius*1.05);\n    grad.addColorStop(0, '#333');\n    grad.addColorStop(0.5, 'white');\n    grad.addColorStop(1, '#333');\n    ctx.strokeStyle = grad;\n    ctx.lineWidth = radius*0.1;\n    ctx.stroke();\n    ctx.beginPath();\n\n    // draws the center dot on the clock\n    ctx.arc(0, 0, radius*0.05, 0, 2*Math.PI);\n    ctx.fillStyle = '#333';\n    ctx.fill();\n  }\n\n  function drawDegreeNumbers(ctx: CanvasRenderingContext2D, radius: number, reverse: boolean): void {\n    let ang: number = 0;\n\n    ctx.font = radius*0.04 + \"px arial\";\n    ctx.textBaseline=\"middle\";\n    ctx.textAlign=\"center\";\n\n    // so we start at 3 o'clock\n    // and move clockwise\n    ctx.rotate(Math.PI/2);\n\n    if (reverse) {\n      for(let num: number = 0; num < 36; num++){\n        ang = num * Math.PI/18;\n        ctx.fillStyle = 'red';\n        ctx.rotate(ang);\n        ctx.translate(0, -radius*0.58);\n        ctx.fillText((num*10).toString(), 0, 0);\n        ctx.translate(0, radius*0.58);\n        ctx.rotate(-ang);\n      }\n    } else {\n      for(let num: number = 36; num > 0; num--){\n        ang = num * -Math.PI/18;\n        ctx.fillStyle = 'blue';\n        ctx.rotate(ang);\n        ctx.translate(0, -radius*0.68);\n        ctx.fillText((num*10).toString(), 0, 0);\n        ctx.translate(0, radius*0.68);\n        ctx.rotate(-ang);\n      }\n    }\n\n    ctx.rotate(-Math.PI/2);\n  }\n\n  function drawDegreeMarkers(ctx: CanvasRenderingContext2D, radius: number): void {\n    let ang: number = 0;\n\n    // so we start at 3 o'clock\n    ctx.rotate(Math.PI/2);\n\n    for(let num = 0; num < 360; num++) {\n      ang = num * Math.PI/180;\n      ctx.lineWidth = 1;\n      ctx.fillStyle = 'black';\n      ctx.rotate(ang);\n\n      ctx.beginPath();\n\n      if (num === 0 || num % 5 === 0) {\n        ctx.moveTo(0, -radius*0.71);\n        ctx.lineTo(0, -radius*.76);\n        ctx.stroke();\n      } else {\n        ctx.moveTo(0, -radius*0.73);\n        ctx.lineTo(0, -radius*.76);\n        ctx.stroke();\n      }\n\n      ctx.moveTo(0,0);\n      ctx.rotate(-ang);\n    }\n\n    ctx.rotate(-Math.PI/2);\n  }\n\n  function drawTimeNumbers(ctx: CanvasRenderingContext2D, radius: number): void {\n    let ang: number = 0;\n\n    ctx.font = radius*0.13 + \"px arial\";\n    ctx.textBaseline=\"middle\";\n    ctx.textAlign=\"center\";\n    for(let num: number = 1; num < 13; num++){\n      ang = num * Math.PI / 6;\n      ctx.fillStyle = 'black';\n      ctx.rotate(ang);\n      ctx.translate(0, -radius*0.85);       // we are rotating the canvas\n      ctx.rotate(-ang);                     // here to make the clock\n      ctx.fillText(num.toString(), 0, 0);   // numbers straight up and down\n      ctx.rotate(ang);\n      ctx.translate(0, radius*0.85);\n      ctx.rotate(-ang);\n    }\n  }\n\n  // draws the time on the clock on the left\n  function drawTime(ctx: CanvasRenderingContext2D, radius: number): void {\n    let h: number = Number(hour.value);\n    let m: number = Number(minute.value);\n    let s: number = Number(second.value);\n\n    //hour\n    h = h % 12;\n    h = convertToRadians('hours', h, m, s);\n    drawHand(ctx, h, radius*0.71, radius*0.03);\n\n    //minute\n    m = convertToRadians('minutes', h, m, s);\n    drawHand(ctx, m, radius*0.8, radius*0.03);\n\n    // second\n    s = convertToRadians('seconds', h, m, s);\n    drawHand(ctx, s, radius*0.9, radius*0.01);\n  }\n\n  function convertToRadians(unit: string, h: number, m: number, s: number): number {\n    let radians: number = 0;\n\n    // so the additional clock shows\n    // angle lines on page load\n    if (h == 0) {\n      h = 12;\n    }\n\n    switch(unit) {\n      case 'hours':\n        radians = (h*Math.PI/6) +          // 30 degrees for one hour\n                  (m*Math.PI/(6*60)) +     // 1/60th of 30 degrees for each minute\n                  (s*Math.PI/(6*60*60));   // 1/60th of 1/60th of 30 degrees for each second\n        break;\n      case 'minutes':\n        radians = (m*Math.PI/30) +\n                  (s*Math.PI/(30*60));     // 6 degrees per minute plus 1/60th of that for each second\n        break;\n      case 'seconds':\n        radians = (s*Math.PI/30);          // because the second hand points at each minute\n        break;\n    }\n\n    return radians;\n  }\n\n  // draw each clock hand\n  function drawHand(ctx: CanvasRenderingContext2D, pos: number, length: number, width: number): void {\n    ctx.beginPath();\n    ctx.lineWidth = width;\n    ctx.lineCap = \"round\";\n    ctx.strokeStyle = \"rgba(0,0,0,0.3)\";\n    ctx.moveTo(0,0);\n    ctx.rotate(pos);\n    ctx.lineTo(0, -length); // negative length because the context has been rotated\n    ctx.stroke();\n    ctx.rotate(-pos);\n  }\n\n  // draw the angle between the hour and minute hand\n  function drawAngles(ctx: CanvasRenderingContext2D, radius: number, time: timeToRender, additional: boolean): void {\n    let h: number = (additional) ? Number(time.hour) : Number(hour.value);\n    let m: number = (additional) ? Number(time.minutes) : Number(minute.value);\n    let s: number = (additional) ? Number(time.seconds) : Number(second.value);\n\n    let startPosition: number = convertToRadians('minutes', h, m, s);\n    let endPosition: number = convertToRadians('hours', h, m, s);\n\n    // so we start at 12 o'clock\n    ctx.rotate(-Math.PI/2);\n\n    // inner angle\n    ctx.beginPath();\n    ctx.arc(0, 0, radius*0.55, startPosition, endPosition);\n    ctx.strokeStyle = 'red';\n    ctx.stroke();\n\n    // outer angle\n    ctx.beginPath();\n    ctx.arc(0, 0, radius*0.65, endPosition, startPosition);\n    ctx.strokeStyle = 'blue';\n    ctx.stroke();\n\n    ctx.rotate(Math.PI/2);\n\n    // outer angle in radians is (2*Math.PI - endPosition + startPosition)\n    outerAngleDegrees = (2*Math.PI - endPosition + startPosition) * 180/Math.PI;\n\n    // for when the minute hand wraps past the hour hand\n    if (outerAngleDegrees > 360) {\n      outerAngleDegrees = outerAngleDegrees - 360;\n    }\n\n    // inner angle in radians is (endPosition - startPosition)\n    innerAngleDegrees = -((endPosition - startPosition) * 180/Math.PI);\n\n    // for when the minute hand wraps past the hour hand\n    if (innerAngleDegrees > 0) {\n      innerAngleDegrees = -(360 - innerAngleDegrees);\n    }\n\n    if (additional) {\n      // assign to right hand clock\n      c2_posAngle.innerHTML = (outerAngleDegrees.toFixed(4)).toString();\n      c2_negAngle.innerHTML = (innerAngleDegrees.toFixed(4)).toString();\n    } else {\n      // assign to left hand clock\n      c1_posAngle.innerHTML = (outerAngleDegrees.toFixed(4)).toString();\n      c1_negAngle.innerHTML = (innerAngleDegrees.toFixed(4)).toString();\n    }\n\n  }\n\n  return {\n    draw: draw,\n    getContext: function() {\n      return ctx;\n    }\n  }\n})();\n\n\n"]}